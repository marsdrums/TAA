<jittershader name="default">
	<description>Default Slab </description>
	<param name="currCol" type="int" default="0" />
	<param name="prevCol" type="int" default="1" />
	<param name="vel" type="int" default="2" />
	<param name="MVP" type="vec2" state="MODELVIEW_PROJECTION_MATRIX" />
	<param name="pos" type="vec3" state="POSITION" />
	<param name="uv" type="vec2" state="TEXCOORD" />
	<param name="viewPort" type="vec2" state="VIEWPORT" />
	<language name="glsl" version="1.5">
		<bind param="currCol" program="fp" />
		<bind param="prevCol" program="fp" />
		<bind param="vel" program="fp" />
		<bind param="MVP" program="vp" />
		<bind param="pos" program="vp" />
		<bind param="uv" program="vp" />
		<bind param="viewPort" program="vp" />
		<program name="vp" type="vertex"  >

<![CDATA[
#version 330 core
			
in vec3 pos;
in vec2 uv;
out jit_PerVertex {
	vec2 uv;
	flat vec2 viewPort;
} jit_out;
uniform mat4 MVP;
uniform vec2 viewPort;
			
void main(void) {

	gl_Position = MVP*vec4(pos, 1.);
	jit_out.uv = uv;//vec2(uv.x, 1. - uv.y);
	jit_out.viewPort = viewPort;
}
]]>
</program>
		
<program name="fp" type="fragment"  >
<![CDATA[
#version 330 core
			
in jit_PerVertex {
	vec2 uv;
	flat vec2 viewPort; 
} jit_in;
layout (location = 0) out vec4 col;
			
uniform sampler2DRect currCol, prevCol, vel;


// the shader is applied as a fullscreen pass(fragment shader), that implements temporal anti-aliasing

// fullscreen UV coordinates. (0,0) in top-left, (1,1) in right-bottom for my engine. 
//in vec2 fsUv;

//out vec4 fragColor;

//uniform int uFirstFrame;
//uniform vec2 uPixelSize;

/*
In my engine, this is the HDR image that we get AFTER the deferred lighting has been done,
and BEFORE the tonemapping is applied.
hdrTex = HDR image of current frame
histHdrTex = HDR image of previous frame.
*/
//uniform sampler2D hdrTex;
//uniform sampler2D histHdrTex;

// velocity texture. 
//uniform sampler2D velocityTex;

// halton low discrepancy sequence, from https://www.shadertoy.com/view/wdXSW8
vec2 halton (int index)
{
    const vec2 coprimes = vec2(2.0f, 3.0f);
    vec2 s = vec2(index, index);
	vec4 a = vec4(1,1,0,0);
    while (s.x > 0. && s.y > 0.)
    {
        a.xy = a.xy/coprimes;
        a.zw += a.xy*mod(s, coprimes);
        s = floor(s/coprimes);
    }
    return a.zw;
}


void main() {
	
    vec3 c;
    /*
    if(uFirstFrame == 1) {
        // first frame, no blending at all.
        c.xyz = texture(currCol, jit_in.uv).xyz;
    } else {  
    */
    	vec2 currUV = jit_in.uv*jit_in.viewPort;
        vec3 neighbourhood[9] = vec3[] ( 	texture(currCol, currUV + vec2(-1, -1) ).xyz,
        									texture(currCol, currUV + vec2(+0, -1) ).xyz,
        									texture(currCol, currUV + vec2(+1, -1) ).xyz,
        									texture(currCol, currUV + vec2(-1, +0) ).xyz,
        									texture(currCol, currUV + vec2(+0, +0) ).xyz,
        									texture(currCol, currUV + vec2(+1, +0) ).xyz,
        									texture(currCol, currUV + vec2(-1, +1) ).xyz,
        									texture(currCol, currUV + vec2(+0, +1) ).xyz,
        									texture(currCol, currUV + vec2(+1, +1) ).xyz
        								);
        

        vec3 nmin = neighbourhood[0];
        vec3 nmax = neighbourhood[0];   
        for(int i = 1; i < 9; ++i) {
            nmin = min(nmin, neighbourhood[i]);
            nmax = max(nmax, neighbourhood[i]);
        }
           
        vec2 vel = texture(vel, vec2(jit_in.uv.x, 1. - jit_in.uv.y)*jit_in.viewPort).rg;
        		//vel *= jit_in.viewPort;
        vec2 histUv = (vec2(jit_in.uv.x, 1. - jit_in.uv.y) - vel.xy)*jit_in.viewPort + vec2(0., 0.);
        
        // sample from history buffer, with neighbourhood clamping.  
        vec3 histSample = clamp(texture(prevCol, histUv).xyz, nmin, nmax);
        
        // blend factor
        float blend = 0.0;
        
        if(histUv.x < 0. || histUv.x > jit_in.viewPort.x || histUv.y < 0. || histUv.y > jit_in.viewPort.y)
        {
        	blend = 1.;
        }
/*
        bvec2 a = greaterThan(histUv, vec2(0.0, 0.0));
        bvec2 b = lessThan(histUv, jit_in.viewPort);
        // if history sample is outside screen, switch to aliased image as a fallback.
        blend = any(bvec2(any(a), any(b))) ? 1.0 : blend;
 */      
        vec3 curSample = neighbourhood[4];
        // finally, blend current and clamped history sample.
        c = mix(histSample, curSample, vec3(blend)  );
      
    
    //col = vec4(c.xyz, 1.0);
    col = vec4(c, 1.);
}
]]>
</program>
</language>
</jittershader>
